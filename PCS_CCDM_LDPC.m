clear,clc

close all
%% Part I PCS symbols generation
lam = 0.03;             %0.015 for256QAM  0.04 for 64qam  0.064=32QAM 0.13338=16qam
m = 3;
mQAM = 2^(2*m);         % order of the mQAM
level = 1:2:2^m-1;      % amplitude level of single-side PAM
pOpt = exp(-lam*level.^2)./sum(exp(-lam*level.^2)); % Probability distribution of the single-side PAM
PAS_len = 1800;         % length of one PAS sequence

% calculate bits input length kc, and the optimal n-type approximation (nc)
% one CCDM block contains PAS_len amplitudes, and encoded num_info_bits bits
[p_quant,num_info_bits,n_i] = ccdm.initialize(pOpt,PAS_len);
PAS_levels = n_i; % number of different amplitudes, like 2 for {1,3}, 4 for {1,3,5,7}
m = log2(length(PAS_levels))+1; % the m in {1,3,5,...,2^m-1}
pwr_scale = 2*sum((1:2:2^m-1).^2.*p_quant');
H_PAS_design_PAS = -sum(pOpt.*log2(pOpt));        % Entropy of the PAS signal
H_PAS_design_QAM = (-sum(pOpt.*log2(pOpt))+1)*2;  % Entropy of the PCS QAM signal
H_PAS_realized = (-sum(p_quant.*log2(p_quant))+1)*2;

LDPC_len = 64800;  % The block length of the code is 64800
LDPC_rate = 9/10;  % LDPC FEC rate, OH bits/information bits
% LDPC_rate = (m-1)/m; % if gamma is zero, LDPC_rate = (m-1)/m
% Possible values for R are 1/4, 1/3, 2/5, 1/2, 3/5, 2/3, 3/4, 4/5, 5/6,
% 8/9, and 9/10. The block length of the code is 64800

R_DM = num_info_bits/PAS_len;  % rate of Distribution Matcher,
% i.e. how many bits per amp

% LDPC_len is the n in the paper
% amplitudes after DM, V1
V1_num = LDPC_len/m;
% bits into DM, U1
U1_num = V1_num*R_DM;
% bits combined with U2 into FEC, by Gray mapping V1 into bits
V1_bits_num = V1_num*(m-1);
% bits combined with V1_bits into FEC, U2
U2_num = LDPC_len*LDPC_rate - V1_bits_num;


% Num of CCDM blocks to add up to U1 bits
N = round(U1_num/num_info_bits);
% generate uniform bits of input length m

W = 100;%floor(2*pi*abs(beta2)*B*Rs*L);

src_bits_XI = randi(2,N,num_info_bits)-1; % source information bits, subtract v bits for the flipping bits
src_bits_XQ = randi(2,N,num_info_bits)-1; % source information bits, subtract v bits for the flipping bits
src_bits_YI = randi(2,N,num_info_bits)-1; % source information bits, subtract v bits for the flipping bits
src_bits_YQ = randi(2,N,num_info_bits)-1; % source information bits, subtract v bits for the flipping bits

% code_sym_seq_I -- V1 sequence
% code_sym_blk_I -- V1 in blocks
% V1_bits -- V1 into bits by Gray mapping
% V1_bits_blk -- V1_bits in blocks
[code_sym_seq_XI, code_sym_blk_XI, V1_bits_XI, V1_bits_blk_XI] = generatePAS_block(src_bits_XI, PAS_len, PAS_levels);
[code_sym_seq_XQ, code_sym_blk_XQ, V1_bits_XQ, V1_bits_blk_XQ] = generatePAS_block(src_bits_XQ, PAS_len, PAS_levels);
[code_sym_seq_YI, code_sym_blk_YI, V1_bits_YI, V1_bits_blk_YI] = generatePAS_block(src_bits_YI, PAS_len, PAS_levels);
[code_sym_seq_YQ, code_sym_blk_YQ, V1_bits_YQ, V1_bits_blk_YQ] = generatePAS_block(src_bits_YQ, PAS_len, PAS_levels);

% initialized the LDPC module

parity = dvbs2ldpc(LDPC_rate);
ldpcencoder = comm.LDPCEncoder(parity);
num_need = size(parity,2)-size(parity,1); % num of whole information bits, V1_bits + U2
U2_XI = randi(2,1,U2_num)-1;
U2_XQ = randi(2,1,U2_num)-1;
U2_YI = randi(2,1,U2_num)-1;
U2_YQ = randi(2,1,U2_num)-1; %these bits are shared by LSAS and EDI

% encodedData -- the encoded bits, V1_bits + U2 ? LDPC ? encodedData
% signs_FEC -- part of signs are generated by FEC overhead
% signs -- all signs, same length of V1_bits/(m-1)
% FEC_bits -- all signs bits, 0 for -1, 1 for 1
[encodedData_XI,signs_FEC_XI,signs_XI,FEC_bits_XI] = LDPC_FEC(V1_bits_XI',U2_XI,parity);
[encodedData_XQ,signs_FEC_XQ,signs_XQ,FEC_bits_XQ] = LDPC_FEC(V1_bits_XQ',U2_XQ,parity);
[encodedData_YI,signs_FEC_YI,signs_YI,FEC_bits_YI] = LDPC_FEC(V1_bits_YI',U2_YI,parity);
[encodedData_YQ,signs_FEC_YQ,signs_YQ,FEC_bits_YQ] = LDPC_FEC(V1_bits_YQ',U2_YQ,parity);
% assign the signs to the amplitudes
code_sym_seq_sign_XI = signs_XI.*code_sym_seq_XI;
code_sym_seq_sign_XQ = signs_XQ.*code_sym_seq_XQ;
code_sym_seq_sign_YI = signs_YI.*code_sym_seq_YI;
code_sym_seq_sign_YQ = signs_YQ.*code_sym_seq_YQ;

gamma = U2_num/V1_num;

%% this  is for VPI reading the bits and mapping into QAM and send
Tx_X = complex(code_sym_seq_sign_XI,code_sym_seq_sign_XQ);
Tx_Y = complex(code_sym_seq_sign_YI,code_sym_seq_sign_YQ);

SNR_vec  = 12:30;
for ind = 1:length(SNR_vec)
    SNR = SNR_vec(ind);
    Rx_X = awgn(Tx_X,SNR,'measured');
    Rx_Y = awgn(Tx_Y,SNR,'measured');
    
    figure(1)
    subplot(221)
    histogram2(real(Tx_X),imag(Tx_X),sqrt(mQAM),'FaceColor','flat');title('Distribution of Tx X')
    subplot(222)
    histogram2(real(Tx_Y),imag(Tx_Y),sqrt(mQAM),'FaceColor','flat');title('Distribution of Tx X')
    subplot(223)
    plot(Rx_X,'.','Markersize',1);title('Rx X');axis square
    subplot(224)
    plot(Rx_Y,'.','Markersize',1);title('Rx Y');axis square
    sgtitle(['SNR = ',num2str(SNR),'dB'])
    
    %%
    if m == 2
        d = (0:15)';
        const_QAM = qammod(d,16,'bin');
        bits = {'0 0 0 0 ', '0 0 0 1 ', '0 0 1 1 ', '0 0 1 0 ','0 1 0 0 ','0 1 0 1 ','0 1 1 1 ','0 1 1 0 ',...
            '1 1 0 0 ','1 1 0 1 ','1 1 1 1 ','1 1 1 0 ','1 0 0 0 ','1 0 0 1 ','1 0 1 1 ','1 0 1 0 '};
    elseif m == 3
        d = (0:63)';
        const_QAM = qammod(d,64,'bin');
        bits = {'0 0 0 0 0 0 ', '0 0 0 0 0 1 ', '0 0 0 0 1 1 ', '0 0 0 0 1 0 ','0 0 0 1 1 0 ','0 0 0 1 1 1 ','0 0 0 1 0 1 ','0 0 0 1 0 0 ',...
            '0 0 1 0 0 0 ', '0 0 1 0 0 1 ', '0 0 1 0 1 1 ', '0 0 1 0 1 0 ','0 0 1 1 1 0 ','0 0 1 1 1 1 ','0 0 1 1 0 1 ','0 0 1 1 0 0 ',...
            '0 1 1 0 0 0 ', '0 1 1 0 0 1 ', '0 1 1 0 1 1 ', '0 1 1 0 1 0 ','0 1 1 1 1 0 ','0 1 1 1 1 1 ','0 1 1 1 0 1 ','0 1 1 1 0 0 ',...
            '0 1 0 0 0 0 ', '0 1 0 0 0 1 ', '0 1 0 0 1 1 ', '0 1 0 0 1 0 ','0 1 0 1 1 0 ','0 1 0 1 1 1 ','0 1 0 1 0 1 ','0 1 0 1 0 0 ',...
            '1 1 0 0 0 0 ', '1 1 0 0 0 1 ', '1 1 0 0 1 1 ', '1 1 0 0 1 0 ','1 1 0 1 1 0 ','1 1 0 1 1 1 ','1 1 0 1 0 1 ','1 1 0 1 0 0 ',...
            '1 1 1 0 0 0 ', '1 1 1 0 0 1 ', '1 1 1 0 1 1 ', '1 1 1 0 1 0 ','1 1 1 1 1 0 ','1 1 1 1 1 1 ','1 1 1 1 0 1 ','1 1 1 1 0 0 ',...
            '1 0 1 0 0 0 ', '1 0 1 0 0 1 ', '1 0 1 0 1 1 ', '1 0 1 0 1 0 ','1 0 1 1 1 0 ','1 0 1 1 1 1 ','1 0 1 1 0 1 ','1 0 1 1 0 0 ',...
            '1 0 0 0 0 0 ', '1 0 0 0 0 1 ', '1 0 0 0 1 1 ', '1 0 0 0 1 0 ','1 0 0 1 1 0 ','1 0 0 1 1 1 ','1 0 0 1 0 1 ','1 0 0 1 0 0 '};
    end
    for kk = 1:length(const_QAM)
        [~,c]=find(abs(Tx_X - const_QAM(kk))<0.01);
        bit_sequence_X(c) = bits(kk);
        [~,c]=find(abs(Tx_Y - const_QAM(kk))<0.01);
        bit_sequence_Y(c) = bits(kk);
        aa=1;
    end
    bit_sequence_X = strjoin(string(bit_sequence_X),'');
    bit_sequence_Y = strjoin(string(bit_sequence_Y),'');
    
    temp = cell2mat(bits);
    temp(temp==' ')=[];
    bits_char = reshape(temp,[],mQAM)';
    %% AIR
    prob = ([flip(p_quant);p_quant]/2);
    prob_QAM_vec = reshape(prob*prob',[],1);
    LLR_vector_QAM_X = LLR_QAM(Rx_X,Tx_X,mQAM,bits_char,const_QAM,prob_QAM_vec); % if LLR>0,
    LLR_vector_QAM_Y = LLR_QAM(Rx_Y,Tx_Y,mQAM,bits_char,const_QAM,prob_QAM_vec); % if LLR>0,
    
    Xedges = -mQAM^0.5:2:mQAM^0.5;
    Yedges = Xedges;
    N_X = histcounts2(real(Tx_X),imag(Tx_X),Xedges,Yedges);
    prob_relaized_X = reshape(N_X/sum(sum(N_X)),[],1);
    FirTerm_X = -sum(prob_relaized_X(prob_relaized_X~=0).*log2(prob_relaized_X(prob_relaized_X~=0)));
    
    N_Y = histcounts2(real(Tx_Y),imag(Tx_Y),Xedges,Yedges);
    prob_relaized_Y = reshape(N_Y/sum(sum(N_Y)),[],1);
    FirTerm_Y = -sum(prob_relaized_Y(prob_relaized_Y~=0).*log2(prob_relaized_Y(prob_relaized_Y~=0)));
    
    temp1 = convertStringsToChars(bit_sequence_X);
    temp1(temp1==' ')=[];
    bits_char1 = reshape(temp1,log2(mQAM),[]);
    SentBitBySymbol_X = double(bits_char1)-double('0');% each col is the bit of a symbol
    SecTerm_X = sum(sum(log2(1+exp((-1).^SentBitBySymbol_X.*-LLR_vector_QAM_X))))/length(Tx_X);
    AIR_X = FirTerm_X-SecTerm_X-(H_PAS_design_PAS - R_DM);
    
    temp2 = convertStringsToChars(bit_sequence_Y);
    temp2(temp2==' ')=[];
    bits_char2 = reshape(temp2,log2(mQAM),[]);
    SentBitBySymbol_Y = double(bits_char2)-double('0');% each col is the bit of a symbol
    SecTerm_Y = sum(sum(log2(1+exp((-1).^SentBitBySymbol_Y.*-LLR_vector_QAM_Y))))/length(Tx_Y);
    AIR_Y = FirTerm_Y-SecTerm_Y-(H_PAS_design_PAS - R_DM);
    
    AIR(ind) = (AIR_X + AIR_Y)/2;
    %% FEC LDPC Decoder
    pwr_scale = 2*sum((1:2:2^m-1).^2*p_quant);
    
    %% LLR decision
    M = 2^m;
    x = (0:M-1)';
    [y,mapy] = bin2gray(x,'pam',M);
    Gray = dec2bin(y, m);
    Amps = (-2^m+1:2:2^m-1)';
    prob = [flip(p_quant);p_quant]/2;
    %  setups = table(Amps, Gray, prob)
    
    % hard decision from LLR
    LLR_vector_XI = LLR(real(Rx_X),code_sym_seq_sign_XI,M,Gray,Amps,prob); % if LLR>0, 0
    LLR_vector_XQ = LLR(imag(Rx_X),code_sym_seq_sign_XQ,M,Gray,Amps,prob); % if LLR>0, 0
    LLR_vector_YI = LLR(real(Rx_Y),code_sym_seq_sign_YI,M,Gray,Amps,prob); % if LLR>0, 0
    LLR_vector_YQ = LLR(imag(Rx_Y),code_sym_seq_sign_YQ,M,Gray,Amps,prob); % if LLR>0, 0
    hard_decision_metric_XI = 0.5-sign(LLR_vector_XI)/2;
    hard_decision_metric_XQ = 0.5-sign(LLR_vector_XQ)/2;
    hard_decision_metric_YI = 0.5-sign(LLR_vector_YI)/2;
    hard_decision_metric_YQ = 0.5-sign(LLR_vector_YQ)/2;
    
    % Define Gray code mapping table
    mappingTable_bits = Gray -'0';
    mappingTable_s = Amps;
    
    parity = dvbs2ldpc(LDPC_rate);
    ldpcdecoder = comm.LDPCDecoder(parity);
    
    % FEC decoder XI
    BER_FEC_XI = DeFEC(LLR_vector_XI,V1_bits_XI,U2_XI,ldpcdecoder);
    BER_FEC_XQ = DeFEC(LLR_vector_XQ,V1_bits_XQ,U2_XQ,ldpcdecoder);
    BER_FEC_YI = DeFEC(LLR_vector_YI,V1_bits_YI,U2_YI,ldpcdecoder);
    BER_FEC_YQ = DeFEC(LLR_vector_YQ,V1_bits_YQ,U2_YQ,ldpcdecoder);
    
    % reshape the sign bits, move it from the first level to the end of the
    % FEC block
    BER_Raw_XI = BER_Raw(hard_decision_metric_XI,encodedData_XI);
    BER_Raw_XQ = BER_Raw(hard_decision_metric_XQ,encodedData_XQ);
    BER_Raw_YI = BER_Raw(hard_decision_metric_YI,encodedData_YI);
    BER_Raw_YQ = BER_Raw(hard_decision_metric_YQ,encodedData_YQ);
    
    FEC_result(ind) = mean([BER_FEC_XI,BER_FEC_XQ,BER_FEC_YI,BER_FEC_YQ]);
    Raw_result(ind) = mean([BER_Raw_XI,BER_Raw_XQ,BER_Raw_YI,BER_Raw_YQ]);
end

figure(2)
plot(SNR_vec, AIR,'*-');grid on
xlabel('SNR  (dB)');ylabel('AIR  (bits/sym)')
figure(3)
semilogy(SNR_vec,Raw_result,'*-',SNR_vec,FEC_result,'*-');grid on
xlabel('SNR  (dB?');ylabel('BER');
legend('Pre FEC','Post FEC')